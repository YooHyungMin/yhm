import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

/*
 * 작성자 : 유형민
 * 문제 : 성곽
 * 번호 : 백준 2234번
 * 
 * 실패 원인 : dp를 이용한 최대 방의 갯수 구하는 방법을 찾지 못함
 * 해당 방의 크기를 visited배열에 갱신해주려 했으나 각 방의 크기가 동일하게 갱신되지 않음
 * 이유는 먼저 도착하는 해당 방의 끝지점이 먼저 갱신되고 다음 긴지점이 갱신되기 때문
 * 완료 부분 : 전체 방의 갯수와 최대 방의 크기를 dfs를 이용하여 구함
 * 
 * 풀이 소스를 보고 깨달은 부분 : 방의 index와 방의 크기를 넣을 배열을 선언하고 전체 좌표를 돌면서 주변 index가 다를 경우 크기 더해주면서 최대 크기 구하기
 */

public class Solution {
	static int castle[][];
	static int roomNumber[][];
	static int roomSize[];

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());

		int N = Integer.parseInt(st.nextToken());
		int M = Integer.parseInt(st.nextToken());

		castle = new int[M][N];
		roomNumber = new int[M][N];
		roomSize = new int[N * M];

		for (int i = 0; i < castle.length; ++i) {
			st = new StringTokenizer(br.readLine());
			for (int j = 0; j < castle[0].length; ++j) {
				castle[i][j] = Integer.parseInt(st.nextToken());
				roomNumber[i][j] = -1;
			}
		}

		/*
		 * dfs함수에 각 좌표와 index값을 전달하고 dfs를 통해 반환된 방의 크기를 roomSize[index]에 삽입한다.
		 */
		int index = 0;
		int MAX = 0;
		for (int i = 0; i < M; i++) {
			for (int j = 0; j < N; j++) {
				/* 방의 번호가 입력이 안된 경우 */
				if (roomNumber[i][j] == -1) {
					/* 방크기 입력 */
					roomSize[index] = dfs(i, j, index);

					if (MAX < roomSize[index])
						MAX = roomSize[index];
					index = index + 1;
				}
			}
		}

		System.out.println(index);
		System.out.println(MAX);
		System.out.println(roomMaxSize());
	}

	private static int roomMaxSize() {
		int MAX = 0;
		int dx[] = { 0, -1, 0, 1 };
		int dy[] = { -1, 0, 1, 0 };

		for (int i = 0; i < roomNumber.length; i++) {
			for (int j = 0; j < roomNumber[0].length; j++) {
				for (int k = 0; k < 4; k++) {
					int nx = i + dx[k];
					int ny = j + dy[k];

					if (!(nx >= 0 && nx < roomNumber.length && ny >= 0 && ny < roomNumber[0].length))
						continue;
					/*
					 * 현재 좌표 방번호와 다음 좌표 방번호가 다르면서 현재 좌표가 -1이 아닐경우 인접한 경우 방크기의 최댓값
					 */
					if (roomNumber[i][j] != -1 && roomNumber[i][j] != roomNumber[nx][ny]) {
						if (MAX < roomSize[roomNumber[i][j]] + roomSize[roomNumber[nx][ny]])
							MAX = roomSize[roomNumber[i][j]] + roomSize[roomNumber[nx][ny]];
					}
				}
			}
		}

		return MAX;
	}

	/*
	 * 각 x,y좌표와 index값을 파라미터로 전달받아 각좌표와 갱신하며 방의 크기를 확인한다.
	 */
	private static int dfs(int x, int y, int index) {
		/*
		 * 4방향으로 이동하면서 이동할 수 있을 경우에만 이동하고 roomSize를 +1 해준다.
		 */
		int size = 1;
		int dx[] = { 0, -1, 0, 1 };
		int dy[] = { -1, 0, 1, 0 };

		/* 각 방 번호 설정 */
		roomNumber[x][y] = index;
		for (int i = 0; i < 4; i++) {
			int nx = x + dx[i];
			int ny = y + dy[i];

			/* 벽이 없는 방향이면서 다음 방이 0일 경우 */
			if (((castle[x][y] & (1 << i)) == 0) && (roomNumber[nx][ny] == -1)) {
				size += dfs(nx, ny, index);
			}
		}

		return size;
	}
}