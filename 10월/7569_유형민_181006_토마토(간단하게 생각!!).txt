import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

/*
 * 작성자 : 유형민
 * 문제 : 토마토
 * 번호 : 백준 7569번
 * 작성일 : 2018.10.06
 * 
 * 실패원인 : 테스트 케이스는 모두 맞았지만 원인을 찾을 수가 없음....
 * 2차원 배열로 해결하려 했는데 코드가 꼬인것 같다.
 * 깨달음 : BFS로 하나씩 이동하면서 count갱신 , 3차원 배열로 하니 바로성공....
 */

public class Main {
	static int tomatoBox[][][]; // 토마토 상자

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());

		int N = Integer.parseInt(st.nextToken()); // 가로
		int M = Integer.parseInt(st.nextToken()); // 세로
		int H = Integer.parseInt(st.nextToken()); // 높이

		tomatoBox = new int[H][M][N];
		Queue<Pair> q = new LinkedList<>();

		boolean check = false;
		for (int i = 0; i < H; i++) {
			for (int j = 0; j < M; j++) {
				st = new StringTokenizer(br.readLine());
				for (int k = 0; k < N; k++) {
					tomatoBox[i][j][k] = Integer.parseInt(st.nextToken());

					if (tomatoBox[i][j][k] == 1) {
						q.add(new Pair(i, j, k, 0));
						check = true;
					}
				}
			}
		}

		if (!check)
			System.out.println(-1);
		else
			System.out.println(growTomato(q, N, M, H));
	}

	private static int growTomato(Queue<Pair> pq, int N, int M, int H) {
		Queue<Pair> q = pq;
		Pair p = null;

		// 6방향으로 확인하면서 count와 좌표를 갱신한다.
		// 위아래 방향은 M만큼 증가 하거나 감소
		int dx[] = { 0, 0, 1, -1, 0, 0 };
		int dy[] = { 1, -1, 0, 0, 0, 0 };
		int dz[] = { 0, 0, 0, 0, 1, -1 };

		while (!q.isEmpty()) {
			p = q.poll();

			for (int i = 0; i < 6; i++) {
				int nx = p.getX() + dx[i];
				int ny = p.getY() + dy[i];
				int nz = p.getZ() + dz[i];

				/* 범위 확인 */
				if (!isRange(nx, ny, nz, H, N, M))
					continue;

				/* 익지 않은 토마토이면서 방문하지 않은 경우 */
				if (tomatoBox[nx][ny][nz] == 0) {
					tomatoBox[nx][ny][nz] = 1;
					q.add(new Pair(nx, ny, nz, p.getDay() + 1));
//					System.out.println(nx + " " + ny + " " + nz + " " + (p.getDay()+1));
				}
			}
		}

		/* 모두 익지 않았을 경우 -1 출력 */
		for (int i = 0; i < H; i++) {
			for (int j = 0; j < M; j++) {
				for (int k = 0; k < N; k++) {
					if (tomatoBox[i][j][k] == 0)
						return -1;
				}
			}
		}

		return p.getDay();
	}

	/* 범위 */
	private static boolean isRange(int x, int y, int z, int H, int N, int M) {
		if (x >= 0 && x < H && y >= 0 && y < M && z >= 0 && z < N)
			return true;
		return false;
	}
}

class Pair {
	private int x;
	private int y;
	private int z;
	private int day;

	public Pair(int x, int y, int z, int day) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.day = day;
	}

	public int getX() {
		return this.x;
	}

	public int getY() {
		return this.y;
	}

	public int getZ() {
		return this.z;
	}

	public int getDay() {
		return this.day;
	}
}