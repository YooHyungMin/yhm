import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

//작성자 : 유형민
//제목 : 네트워크 연결
//번호 : 1922
//수정일 : 2018. 8. 7
//언어 : Java
//필요 알고리즘 : 최소 스패닝 트리 프림 알고리즘
//내용 : 	1. 하나의 시작점을 잡고 연결된 정점들에 대해 가중치가 작은 간선부터 연결
//		2. 가중치가 작더라도 사이클이 생기면 무시

public class Main {
	static int V, E;
	static ArrayList<ArrayList<Node>> adj; // 각정점 간 연결과 가중치 저장배열
	static boolean visited[];

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());

		V = Integer.parseInt(st.nextToken());
		st = new StringTokenizer(br.readLine());
		E = Integer.parseInt(st.nextToken());

		adj = new ArrayList<>();
		visited = new boolean[V + 1];

		for (int i = 0; i <= V; i++) {
			adj.add(new ArrayList<>());
			visited[i] = false;
		}

		for (int i = 0; i < E; i++) {
			st = new StringTokenizer(br.readLine());
			int u = Integer.parseInt(st.nextToken());
			int v = Integer.parseInt(st.nextToken());
			int w = Integer.parseInt(st.nextToken());

			// 무방향
			adj.get(u).add(new Node(v, w));
			adj.get(v).add(new Node(u, w));
		}

		solve(1);
	}

	public static void solve(int start) {
		PriorityQueue<Node> ptq = new PriorityQueue<>();
		Node n = null;
		visited[start] = true;
		int sum = 0;

		//처음 방문할 가중치가 최소인 정점
		for (int i = 0; i < adj.get(start).size(); i++) {
			int to = adj.get(start).get(i).getTo();
			int dist = adj.get(start).get(i).getDist();
			ptq.add(new Node(to, dist));
		}

		while (!ptq.isEmpty()) {
			n = ptq.poll();
			int here = n.getTo();
			int d = n.getDist();

			//사이클이 일어나지 않게 하기 위한 부분
			if (visited[here])
				continue;

			//방문 한곳 확인
			visited[here] = true;

			//최솟값 더하기
			sum += d;
			//방문한 정점의 최솟값을 찾기위한 방문가능한 곳 삽입
			for (int i = 0; i < adj.get(here).size(); i++) {
				int to = adj.get(here).get(i).getTo();
				int dist = adj.get(here).get(i).getDist();
				ptq.add(new Node(to, dist));
			}
		}
		System.out.println(sum);
	}
}

class Node implements Comparable<Node> {
	private int to;
	private int distance;

	public Node(int to, int distance) {
		this.to = to;
		this.distance = distance;
	}

	public int getTo() {
		return this.to;
	}

	public int getDist() {
		return this.distance;
	}

	//올림 차순
	@Override
	public int compareTo(Node a) {
		// TODO Auto-generated method stub
		if (this.getDist() > a.getDist())
			return 1;
		else if (this.getDist() < a.getDist())
			return -1;
		else
			return 0;
	}
}
