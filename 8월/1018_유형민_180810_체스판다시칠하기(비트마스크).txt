import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

//작성자 : 유형민
//제목 : 체스판 다시 칠하기
//번호 : 1018번
//수정일 : 2018. 8. 12
//언어 : Java
//필요 알고리즘 : 비트마스크

public class Main {
	static int N, M;
	static int board[][]; // 전체 보드
	static int bChess[] = { 85, 170, 85, 170, 85, 170, 85, 170 };// 왼쪽 코너
	static int wChess[] = { 170, 85, 170, 85, 170, 85, 170, 85 };// 왼쪽 코너 흰색
	static int bMin, wMin; // black, white 최솟값
	static int wCountSum, bCountSum; // black, white 합

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());

		N = Integer.parseInt(st.nextToken());
		M = Integer.parseInt(st.nextToken());

		board = new int[N][M - 8 + 1];
		wMin = N * M; // 최댓값
		bMin = N * M;

		for (int i = 0; i < N; i++) {
			st = new StringTokenizer(br.readLine());
			String temp = st.nextToken();

			// N*M보드에서 8*8체스판으로 만들수 있는 모든 경우를 board변수에 저장한다.
			// 입력 값을 B는 0 W는 1로
			// 8비트 이진수 값을 만든다.
			for (int k = 0; k < board[0].length; k++) {
				for (int j = 0; j < 8; j++) {
					if (temp.charAt(j + k) == 'B') {
						board[i][k] |= (0 << (8 - j - 1));
					} else if (temp.charAt(j + k) == 'W') {
						board[i][k] |= (1 << (8 - j - 1));
					}
				}
			}
		}

		result();
	}

	private static void result() {
		// 체스판이 될 수 있는 모든 경우의 수를 기존에 선언해놓은 코너가 w,b 일때 배열과 비교하여 최솟값을 찾는다.
		for (int k = 0; k <= N - 8; k++) {
			for (int i = 0; i <= M - 8; i++) {
				wCountSum = 0;
				bCountSum = 0;

				for (int j = 0; j < 8; j++) {
					// 서로 다른 비트의 갯수
					wCountSum += (Integer.bitCount(wChess[j] ^ board[j + k][i]));
					bCountSum += (Integer.bitCount(bChess[j] ^ board[j + k][i]));
				}

				if (wMin > wCountSum) {
					wMin = wCountSum;
				}

				if (bMin > bCountSum) {
					bMin = bCountSum;
				}
			}
		}

		if (bMin > wMin)
			System.out.println(wMin);
		else
			System.out.println(bMin);
	}
}
