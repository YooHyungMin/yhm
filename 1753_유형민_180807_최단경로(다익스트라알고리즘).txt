import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

//작성자 : 유형민
//제목 : 최단경로
//번호 : 1753
//수정일 : 2018. 8. 7
//언어 : Java
//필요 알고리즘 : 다익스트라 알고리즘
//주의사항 : 	1. 다익스트라알고리즘은 정점을 방문할 때마다 가중치가 증가한다는 전제가 있기 때문에 음수 가중치는 허용이 안된다.(음수는 벨만포드 알고리즘)
//		  	2. 우선순위 큐를 사용하는 이유는 우선순위 큐를 통해 최솟값을 먼저 방문하여 모든 인덱스를 방문하지 않는 점 때문에 시간이 빠르다
//			3. 우선순위 큐를 구현할 경우 배열보다는 ArrayList를 사용하여 구현하여야 훨~~씬 빠르다.

public class Main {
	static int V, E;
	static ArrayList<ArrayList<Node>> adj;	//각정점 간 연결과 가중치 저장배열
	static ArrayList<Integer> dist;			//거리 배열

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());

		V = Integer.parseInt(st.nextToken());
		E = Integer.parseInt(st.nextToken());

		adj = new ArrayList<>();
		dist = new ArrayList<>();

		for (int i = 0; i <= V; i++) {
			adj.add(new ArrayList<>());
		}

		//거리의 최댓값으로 저장
		for (int i = 0; i <= V; i++) {
			dist.add(2000001);
		}

		st = new StringTokenizer(br.readLine());
		int start = Integer.parseInt(st.nextToken());

		for (int i = 0; i < E; i++) {
			st = new StringTokenizer(br.readLine());
			int u = Integer.parseInt(st.nextToken());
			int v = Integer.parseInt(st.nextToken());
			int w = Integer.parseInt(st.nextToken());

			adj.get(u).add(new Node(u, v, w));
		}

		solve(start);

		for (int i = 1; i <= V; i++) {
			if (dist.get(i) == 2000001)
				System.out.println("INF");
			else
				System.out.println(dist.get(i));
		}
	}

	public static void solve(int start) {
		PriorityQueue<Pair> ptq = new PriorityQueue<>();
		dist.set(start, 0);
		ptq.add(new Pair(start, dist.get(start)));

		while (!ptq.isEmpty()) {
			Pair p = ptq.poll();

			//현재 정점까지 가중치보다 현재 정점의 가중치가 크면 현재 정점이 최솟값이 아니기 때문에 제외 
			if (p.getDist() > dist.get(p.getV()))
				continue;

			for (int i = 0; i < adj.get(p.getV()).size(); i++) {
				//
				int to = adj.get(p.getV()).get(i).to;

				if (dist.get(to) > adj.get(p.getV()).get(i).distance + dist.get(p.getV())) {
					dist.set(to, adj.get(p.getV()).get(i).distance + dist.get(p.getV()));
					ptq.add(new Pair(to, dist.get(to)));
				}
			}
		}
	}
}

class Node {
	int from;
	int to;
	int distance;

	public Node(int from, int to, int distance) {
		this.from = from;
		this.to = to;
		this.distance = distance;
	}
}


class Pair implements Comparable<Pair>{
	private int v;
	private int distance;

	public Pair(int v, int distance) {
		this.v = v;
		this.distance = distance;
	}

	public int getV() {
		return this.v;
	}

	public int getDist() {
		return this.distance;
	}

	@Override
	public int compareTo(Pair a) {
		// TODO Auto-generated method stub
		if(this.getDist() > a.getDist()) return 1;
		else if(this.getDist() < a.getDist()) return -1;
		else return 0;
	}
}

