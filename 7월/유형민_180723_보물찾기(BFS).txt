import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

//작성자 : 유형민
//제목 :	보물찾기
//수정일 : 2018. 7. 24
//언어 : Java

//제출 오류 !! 반례 찾기

public class Main {
	static int result[];
	static int map[][]; // 맵
	static boolean visited[][]; // 방문 변수
	static int value[];
	static int N, M, K; // 유적의 수, 단서의 수, 남은시간

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int testCase; // 테스트 케이스

		testCase = sc.nextInt();
		result = new int[testCase];

		for (int i = 0; i < testCase; i++) {
			N = sc.nextInt();
			M = sc.nextInt();
			K = sc.nextInt();

			map = new int[N + 1][N + 1];
			visited = new boolean[N + 1][N + 1];
			value = new int[N + 1];
			init();

			for (int j = 0; j < M; j++) {
				int x = sc.nextInt();
				int y = sc.nextInt();

				map[x][y] = 1;
			}

			solve();

			//도착지에 시간이 0이거나 K보다 클 경우 -1
			//시간이 0보다 크거나 K보다 작거나 같으면 최단시간 저장
			if (value[N] == 0 || value[N] > K)
				result[i] = -1;
			else if (value[N] <= K && value[N] > 0)
				result[i] = value[N];
		}
		
		for (int i = 0; i < result.length; i++)
			System.out.println("#" + (i + 1) + " " + result[i]);
	}

	private static void solve() {
		Queue<Point> q = new LinkedList<>();
		Point p = new Point(1, 1);

		q.add(p);
		while (!q.isEmpty()) {
			p = q.poll();
			for (int i = 1; i <= N; i++) {
				//가리키는 곳이 같으면 다음으로
				if(p.y == i) continue;
				
				//이동할 경우 전 위치에서 시간 증가 및 방문 한 곳은 또다시 방문 하지 않게 함
				if (map[p.y][i] == 1 && !visited[p.y][i]) {
					q.add(new Point(p.y, i));
					visited[p.y][i] = true;
					value[i] = value[p.y] + 1;

					//도착했을 경우 종료
					if (i == N)
						return;
				}
			}
		}
	}

	private static void init() {
		for (int i = 0; i < N + 1; i++) {
			for (int j = 0; j < N + 1; j++) {
				visited[i][j] = false;
				map[i][j] = 0;
				value[i] = 0;
			}
		}
	}
}

class Point {
	int x;
	int y;

	public Point(int x, int y) {
		this.x = x;
		this.y = y;
	}
}